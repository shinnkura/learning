https://atcoder.jp/contests/apg4b/tasks/APG4b_ac

## ビット演算
- ビット毎のAND演算
  - `&`
  - 各ビットについて「両方のビットが1ならば1」という操作を適用する。
- ビット毎のOR演算
  - `|`
  - 各ビットについて「少なくとも一方のビットが1ならば1」という操作を適用する。
- ビット毎のXOR演算
  - `^`
  - 各ビットについて「どちらか一方だけが1ならば1」という操作を適用する。
- ビット毎のNOT演算
  - `~`
  - 各ビットについて「ビットを反転する」という操作を適用する。
- 左シフト演算
  - `<<`
  - 指定したビット数だけビット列を左にずらす。範囲外のビットは切り捨てられ、足りないビットは0で埋められる。
- 右シフト演算
  - `>>`
  - 指定したビット数だけビット列を右にずらす。範囲外のビットは切り捨てられ、足りないビットは0で埋められる。


## ビット演算の使い道
- 集合
  - ２つの集合から共通部分を取り出す
    - A=1,2,3,5,7
    - B=1,3,5,7,9
    - 共通する集合は1,3,5,7
  - ビット列で表現
    - Aのビット列は「1110101000」
    - Bのビット列は「1010101010」
    - これらにビット毎のAND演算を適用すると、「1010101000」となり、これは集合1,3,5,7となる

## C++でビット列を扱う
- C++でビット列を扱うときは`bitset`を用いる
```cpp
bitset<ビット数> 変数名;  // すべてのビットが0の状態で初期化される
bitset<ビット数> 変数名("ビット列(長さはビット数に合わせる)");  // 指定したビット列で初期化される

変数.set(位置, 値);  // ビットの値を変更
変数.test(位置);  // ビットの値を調べる
```

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  bitset<8> a("00011011");
  bitset<8> b("00110101");

  auto c = a & b;
  cout << "1: " << c << endl;         // 1: 00010001
  cout << "2: " << (c << 1) << endl;  // 2: 00100010
  cout << "3: " << (c << 2) << endl;  // 3: 01000100
  cout << "4: " << (c << 3) << endl;  // 4: 10001000
  cout << "5: " << (c << 4) << endl;  // 5: 00010000

  c <<= 4;
  c ^= bitset<8>("11010000"); // XOR演算の複合代入演算子
  cout << "6: " << c << endl; // 6: 11000000
}
```

- 操作
  - ビットの値を変更
    - `set`メソッド : 変更するビットの位置を0始まりのインデックスで指定します。値は0か1を指定します。
  - ビットの値を調べる
    - `test`メソッド : 調べるビットの位置を0始まりのインデックスで指定します。ビットが1ならtrueを、ビットが0ならfalseを返します。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
  bitset<4> S;
  S.set(0, 1);  // 0番目のビットを1にする
  cout << S << endl;

  if (S.test(3)) {
    cout << "4th bit is 1" << endl;
  } else {
    cout << "4th bit is 0" << endl;
  }
}

// 0001
// 4th bit is 0
```

- C++の整数型を用いることで(通常)64ビットまでのビット列を扱うことができる
- ビット演算の演算子は優先順位を間違えやすいため、明示的に()でくくるようにする



