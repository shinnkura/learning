https://atcoder.jp/contests/apg4b/tasks/APG4b_aj

## ポインタ

- プログラム上の変数はメモリ上に保存される
- メモリは巨大な配列のようなもの
- メモリ上の位置はアドレスという数値で識別される
- アドレスは配列の添字に対応

- ある型がメモリ上でなんバイトなのかは、`sizeof(型)`で調べられる

```cpp
cout << sizeof(int32_t) << endl; // 4
cout << sizeof(int8_t) << endl;  // 1
```

## ポインタ

- メモリのアドレスは整数値で表すことができる
  - この整数値を扱うための型が`ポインタ型`であり、ポインタ型の変数を`ポインタ`と呼ぶ
- ポインタはアドレスを扱う整数型
- ポインタの使い方

  - ポインタの宣言 `型 *ポインタ;`
  - 変数のアドレスを取得 `&変数`
  - ポインタの指す先へのアクセス(読み書き) `*ポインタ`
  - ポインタそのものへのアクセス `ポインタ`
  - ポインタ経由(構造体)でのメンバアクセス `ポインタ->メンバ`

## ３つ領域
- 静的領域
  - グローバル変数はプログラムの開始から終了までずっと有効な変数なので、 ずっとメモリ上に割り当てられている必要がある
  - プログラム開始時に割り当てられて終了時に解放されればよいので、 グローバル変数のメモリ割り当て・解放はコンパイラによって自動的に行われる
  - このときにグローバル変数が配置されるメモリ領域を静的領域という

- スタック領域
  - ローカル変数はスコープの範囲内で有効なので、 スコープの始まりでメモリを確保し、スコープの終わりでメモリを解放すれば十分
  - ローカル変数の割り当てと解放もコンパイラによって自動的に行われる
  - このときに配置されるメモリ領域をスタック領域という

- ヒープ領域
  - プログラムを設計する上で、何らかの情報を「スコープの範囲を超えて」扱いたいことがあります。 このような場合に利用するのがヒープ領域です。
  - ヒープ領域は柔軟に使える分、プログラマが責任を持って割り当て・解放を行わなければなりません。
  - また、ヒープ領域はポインタを介して読み書きを行う必要があります。
  - ちなみに、ヒープ領域はメモリを有効活用したい場合のためのものです。 メモリ有効活用する必要のない場合は、予めグローバル変数として必要な分だけメモリを確保しておけば十分なことが多いです。



## ヒープ領域
- ヒープ領域の確保

  - `型 *ポインタ1 = new 型;        // 1つ分の領域を確保`
  - `型 *ポインタ2 = new 型[n];     // 連続したn個分の領域を確保`

- ヒープ領域の解放

  - `delete ポインタ1;   //「new 型」で確保したときに返ってきたポインタ`
  - `delete[] ポインタ2; //「new 型[n]」で確保したときに返ってきたポインタ`

<!-- 一つ分のヒープ領域を確保する例 -->
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  uint32_t *p;

  // uint32_t型の変数の分だけヒープ領域からメモリを確保する
  p = new uint32_t;

  // ポインタを介して使う
  *p = 123;
  cout << *p << endl;

  // メモリを解放する
  delete p;
}

// 出力
// 123
```

<!-- 連続した領域を確保する例 -->
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  uint32_t *p;

  // uint32_t型の変数10個分だけ(つまり4*10=40バイト分)ヒープ領域からメモリを確保する
  p = new uint32_t[10];

  // ポインタを介して使う
  uint32_t *tmp = p;  // アドレス値のコピー
  for (int i = 0; i < 10; i++) {
    *tmp = i; // i番目にiを書き込む
    tmp++; // 次の要素を指すように変更
  }

  tmp = p;  // pの位置に戻す
  for (int i = 0; i < 10; i++) {
    cout << *tmp << endl;
    tmp++;
  }

  // メモリを解放する(10個分連続で確保したのでdelete[]を使う)
  delete[] p;
}

// 出力
// 0
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
```



## スマートポインタ
- ２種類のスマートポインタ
  - `std::unique_ptr`
  - `std::shared_ptr`

- `std::unique_ptr`
  - メモリの「所有権」をやりとりし、 不必要になったタイミングで自動的にメモリが解放されます。
  - 常に1つの`std::unique_ptr`が所有権を持っていて、 所有権を持っていないポインタからは対象のメモリ領域を触ることができないようになっています。

- `std::shared_ptr`
  - メモリの「所有権」をやりとりし、 不必要になったタイミングで自動的にメモリが解放されます。
  - 複数の`std::shared_ptr`が所有権を持っていて、 所有権を持っていないポインタからは対象のメモリ領域を触ることができないようになっています。


```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  // int型1つ分の領域を確保(123で初期化)
  unique_ptr<int> p1 = make_unique<int>(123);
  *p1 += 1;
  cout << *p1 << endl;

  unique_ptr<int> p2;
  p2 = move(p1); // メモリの所有権をp2に移動
  //*p1 += 10;  // p1は所有権を失ったのでエラー
  *p2 += 1;
  cout << *p2 << endl;
}  // ここでp2の持っていた所有権が無効になり自動的にメモリが回収される

// 出力
// 124
// 125
```

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  shared_ptr<int> p3;
  {
    shared_ptr<int> p1 = make_shared<int>(123);
    {
      shared_ptr<int> p2 = p1;  // p2も所有権を共有
      *p2 += 1;
      p3 = p2;  // p3も所有権を共有
    } // p2が所有権を手放す(p1, p3が共有している状態)
    *p1 += 1;
  } // p1が所有権を手放す(p3が持っている状態)
  *p3 += 1;
  cout << *p3 << endl;
} // 所有者がいなくなり、メモリが解放される

// 出力
// 126
```
