# 配列(vector)

得意

- ランダムアクセスが得意
  - i 番目の要素にアクセスすること
  - 記録されいてる場所や、書き込みの順序に関係なく直接アクセスすること

苦手

- x を y の直後に挿入
- x を削除する
- 苦手な理由
  - 最悪全ての要素を確認する必要がある
  - また、挿入・削除後に、最悪すべての要素をずらす必要がある

# 連結リスト（linked list）

特定

- x を y の直後に挿入
- x を削除

苦手

- ランダムアクセス
  - i 番目の要素にアクセスすること
  - 記録されいてる場所や、書き込みの順序に関係なく直接アクセスすること

説明

- 連結リストは、各データがポインタで繋がっているデータ構造
  - 各データのことを Node という
  - Node 内には、データと、次のノードを指すポインタが含まれる
    - 次のノードを指すポインタがあることで、
    - 削除するときも、挿入するときも、前のノードのポインタを変更するだけでよい

node の定義

- (単方向)連結リストの定義

```cpp
struct Node {
  Node *next; // 次のノードを指すポインタ
  string name; // 格納しているデータ

  // コンストラクタ
  // デフォルトでは、nextはNULLで、nameは空文字列
  // 引数を与えると、その引数をnameに格納する
  Node(string name_ = "") : next(NULL), name(name_) {}
};
```

- 連結リストの挿入操作
- 太郎->次郎とならんでいる間に、花子を追加する

```cpp
void insert(Node* taro, Node* hanako) {
  hanako->next = taro->next; // 花子の次のノードは、太郎の次のノードだった人にする
  taro->next = hanako; // 太郎の次のノードは、**花子にする**
}
```

- 削除操作

  - 双方向連結リストを用いると、削除操作が容易になる
  - 双方向連結リストは、各ノードが、前のノードと次のノードを指すポインタ両方を持つ
  - 双方向連結リストの定義

  ```cpp
  struct Node {
    Node *prev; // 前のノードを指すポインタ
    Node *next; // 次のノードを指すポインタ
    string name; // 格納しているデータ

    // コンストラクタ
    Node(string name_ = "") : prev(NULL), next(NULL), name(name_) {}
  };
  ```

# ハッシュテーブル

特定

- キーによる検索
- キーによる挿入
- キーによる削除
