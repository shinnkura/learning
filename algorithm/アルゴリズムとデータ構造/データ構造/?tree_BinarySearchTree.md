### **二分探索木（Binary Search Tree, BST）とは？**
**二分探索木（BST）** は、**データを効率的に格納・検索・削除できるツリー構造** です。  
**特定のルールに従った木構造** であり、特に **探索やソート** に優れています。

---

## **1. 二分探索木の基本構造**
二分探索木（BST）は、次のような **ルール** を持ちます：

1. **各ノードには「左の子」と「右の子」がある**
2. **左の子の値は親ノードより小さい**
3. **右の子の値は親ノードより大きい**
4. **このルールが再帰的にすべてのノードで成り立つ**

### **例：二分探索木**
```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
```
✅ **どのノードを見ても「左が小さい、右が大きい」**

---

## **2. 二分探索木の基本操作**
### **(1) 探索（Search）**
- ルートから始めて、**探したい値が小さければ左、大きければ右に進む**。
- **O(log N)** の高速検索が可能（平衡な場合）。

#### **例：`7` を探す**
1. ルート `8` と比較 → `7 < 8` なので左へ
2. ノード `3` と比較 → `7 > 3` なので右へ
3. ノード `6` と比較 → `7 > 6` なので右へ
4. **発見！（ノード `7`）**

---

### **(2) 挿入（Insert）**
- 新しいノードを追加するときも、**比較しながら適切な位置に入れる**。

#### **例：`5` を挿入**
1. `8` と比較 → `5 < 8` なので左へ
2. `3` と比較 → `5 > 3` なので右へ
3. `6` と比較 → `5 < 6` なので左へ
4. **ノード `5` を `6` の左に追加！**
```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
         /
        5  ← 新しく挿入！
```

---

### **(3) 削除（Delete）**
ノードを削除する場合、**3つのケース** に分かれる。

#### **ケース1：削除するノードが「葉ノード」**
- そのまま削除するだけ（子がない）。

**例**: `13` を削除
```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   
      4   7 
```

#### **ケース2：削除するノードに「子が1つ」**
- **親と子を直接つなぐ**。

**例**: `10` を削除
```
        8
       / \
      3   14
     / \   /
    1   6 13
       / \  
      4   7  
```

#### **ケース3：削除するノードに「子が2つ」**
- **右部分木の最小値（または左部分木の最大値）で置き換え**。

**例**: `3` を削除
1. `3` の右部分木で最小値（`4`）を探す
2. `4` で `3` を置き換える
```
        8
       / \
      4   14
     / \   /
    1   6 13
       / \  
          7  
```

---

## **3. 二分探索木の計算量**
| 操作 | 平均ケース | 最悪ケース（偏った木） |
|------|-----------|----------------|
| **探索** | O(log N) | O(N) |
| **挿入** | O(log N) | O(N) |
| **削除** | O(log N) | O(N) |

➡ **木がバランス良く保たれていれば O(log N) だが、偏ると O(N) になる**

### **🛠 解決策：バランスを取る方法**
- **AVL木**
- **赤黒木（Red-Black Tree）**
- **B木**（データベース用）

---

## **4. 二分探索木の実装（C++）**
```cpp
#include <iostream>
using namespace std;

// ノードの定義
struct Node {
    int key;
    Node* left;
    Node* right;
    
    Node(int val) {
        key = val;
        left = right = nullptr;
    }
};

// ノードの挿入
Node* insert(Node* root, int key) {
    if (!root) return new Node(key);
    if (key < root->key) root->left = insert(root->left, key);
    else root->right = insert(root->right, key);
    return root;
}

// ノードの検索
bool search(Node* root, int key) {
    if (!root) return false;
    if (root->key == key) return true;
    return key < root->key ? search(root->left, key) : search(root->right, key);
}

// 中間順巡回（Inorder Traversal）
void inorder(Node* root) {
    if (!root) return;
    inorder(root->left);
    cout << root->key << " ";
    inorder(root->right);
}

int main() {
    Node* root = nullptr;
    root = insert(root, 8);
    insert(root, 3);
    insert(root, 10);
    insert(root, 1);
    insert(root, 6);
    insert(root, 14);
    insert(root, 4);
    insert(root, 7);
    insert(root, 13);
    
    cout << "BSTの要素: ";
    inorder(root);
    cout << endl;

    cout << "7を検索: " << (search(root, 7) ? "見つかった" : "見つからない") << endl;
    cout << "5を検索: " << (search(root, 5) ? "見つかった" : "見つからない") << endl;
    
    return 0;
}
```
### **出力**
```
BSTの要素: 1 3 4 6 7 8 10 13 14
7を検索: 見つかった
5を検索: 見つからない
```

---

## **5. まとめ**
✅ **二分探索木（BST）とは？**  
➡ 左の子が小さく、右の子が大きい木構造。

✅ **主要な操作**
- **探索** → O(log N) で高速
- **挿入** → O(log N) で適切な位置に追加
- **削除** → O(log N) で適切に削除・調整

✅ **注意点**
- **バランスが悪いと O(N) になる**
- **AVL木や赤黒木でバランスを取ると効率が良くなる**

二分探索木は **検索・ソート・データ管理** で頻繁に使われる重要なデータ構造です！