package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("Hello, World!")
	fmt.Println(time.Now())

	///////////////////////////////////////////////////////////
	// 変数の宣言
	///////////////////////////////////////////////////////////
	// 明示的な定義
	// var 変数名 型 = 値
	var name string = "John"

	// 暗黙的な定義
	// 型推論
	// 変数名 := 値
	// ※ 関数内でしか定義できない
	i4 := 4
	fmt.Println(name, i4)

	///////////////////////////////////////////////////////////
	// 型の定義
	///////////////////////////////////////////////////////////
	// byte(uint8)型
	byteA := []byte{72, 73}
	fmt.Println(byteA) // [72 73]
	fmt.Println(string(byteA)) // HI （文字列はアスキーコードとして出力される）

	sbyteA := []byte("HI")
	fmt.Println(sbyteA) // [72 73]
	fmt.Println(string(sbyteA)) // HI


	// 配列とスライス
	// 配列はあとから要素数を変更することができない
	// 後から要素数を変更する場合はスライスを使用する
	
	// 配列
	// 型名 := [要素数]型{値1, 値2, ...}
	arr := [3]int{1, 2, 3}
	fmt.Println(arr) // [1 2 3]
	fmt.Printf("%T\n", arr) // [3]int

	//　要素数を指定しないで配列を定義することもできる
	// 型名 := [...]型{値1, 値2, ...}
	arr2 := [...]int{1, 2}
	fmt.Println(arr2) // [1 2]
	fmt.Printf("%T\n", arr2) // [2]int


	// スライス
	// 型名 := []型{値1, 値2, ...}
	sl := []int{1, 2, 3}
	fmt.Println(sl) // [1 2 3]
}

// コンパイル
// go build -o main main.go

// 実行
// ./main

/*
なぜコンパイルする必要があるのか？

1. ネイティブコードにコンパイルされる
Goはネイティブコードにコンパイルされた上で実行されるので、
一般的なスクリプト言語の実行速度より１０〜１００倍という高いパフォーマンスを発揮する。

2. マルチプラットフォームで動作する
GoはOSやCPUによる実行環境の差を隠蔽してくれる。
この為、実行されるプラットフォームの差に気を配らなくても良い。
各実行環境で動作するプログラムを、１つのコンパイル環境から生成できる、クロスコンパイル機能を備えている。

特にこのクロスコンパイルの恩恵が大きいです。
Goは、1つのソースコードから様々なOS向けのバイナリを生成するクロスコンパイルをサポートしています。

つまり、Mac で .exe ファイルを生成して Windows ユーザにそれを渡せば、受け取った瞬間にすぐに実行できるということ
*/
